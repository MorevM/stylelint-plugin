import { existsSync, globSync } from 'node:fs';
import { basename, dirname, relative, resolve } from 'node:path';
import { pathToFileURL } from 'node:url';
import { asyncArray, formatSlashes, tsObject } from '@morev/utils';
import { NAMESPACE } from '#modules/shared';
import { getAutoGeneratedHeader, getRootPath, writeGeneratedFile } from '../utils';
import type { RuleMeta } from '../types';

const ROOT_PATH = getRootPath();
const RULES_PATH = resolve(ROOT_PATH, 'src', 'rules');

const SCOPE_MAP: Record<string, { label: string; description: string }> = {
	base: {
		label: 'üìè Base',
		description: 'General best practices that are not tied to any particular methodology or preprocessor',
	},
	bem: {
		label: 'üì¶ BEM',
		description: 'Rules specific to the <a href="https://en.bem.info/methodology/" target="_blank" rel="noopener noreferrer">BEM methodology</a>',
	},
	sass: {
		label: 'ü™Ñ SASS',
		description: 'Rules focused on SASS/SCSS syntax and features',
	},
};

const sortAsc = (a: string, b: string) => a.localeCompare(b, 'en');

export const generateRulesMeta = async () => {
	// All rule files follow the structure: `src/rules/<scope>/<rule>/<rule>.ts`.
	const ruleEntries = globSync(`${RULES_PATH}/*/*/*.ts`)
		.filter((file) => {
			const directoryName = basename(dirname(file));
			const fileName = basename(file, '.ts');
			return directoryName === fileName;
		});

	// Import each rule module and extract its metadata.
	const rulesData = await asyncArray(ruleEntries)
		.map<RuleMeta>(async (ruleFile) => {
			const { ruleName, meta } = await import(pathToFileURL(ruleFile).href)
				.then((m) => m.default ?? m);

			const [scope, name] = ruleName.replace(`${NAMESPACE}/`, '').split('/');
			const id = `${NAMESPACE}/${scope}/${name}` as const;

			const ruleDirectory = dirname(ruleFile);
			const docsAbsolutePath = `${ruleDirectory}/${name}.docs.md`;
			const docsRelativePath =  formatSlashes(relative(ROOT_PATH, docsAbsolutePath), { to: '/' });

			// Validate docs presence early to avoid broken links.
			if (!existsSync(docsAbsolutePath)) {
				throw new Error(`Docs file is missing for rule "${id}": ${docsRelativePath}`);
			}

			return {
				id,
				scope,
				name,
				description: meta.description,
				fixable: meta.fixable,
				docsPath: docsRelativePath,
				vitepressPath: `/rules/${scope}/${name}.md`,
				vitepressLink: `/rules/${scope}/${name}.html`,
			};
		});

	// Build a structured collection of rules grouped by scope,
	// with sorting applied for deterministic output.
	const grouped = Object.groupBy(rulesData, ({ scope }) => scope);
	const scopedRuleModules = tsObject.entries(grouped)
		.sort(([scopeA], [scopeB]) => sortAsc(scopeA, scopeB))
		.map(([scope, rules]) => {
			return {
				scope,
				label: SCOPE_MAP[scope].label,
				description: SCOPE_MAP[scope].description,
				items: (rules ?? []).sort((a, b) => sortAsc(a.name, b.name)),
			};
		});

	const header = getAutoGeneratedHeader(import.meta.filename);

	const rulesMetaContents =
		`export const rulesMeta = ${JSON.stringify(rulesData, null, '\t')} as const;`;
	const scopedRulesMetaContents =
		`export const scopedRulesMeta = ${JSON.stringify(scopedRuleModules, null, '\t')} as const;`;
	const typesContents =
		`export type RuleScope = (typeof rulesMeta)[number]['scope']`;

	await writeGeneratedFile(
		'rules-meta.ts',
		[header, rulesMetaContents, scopedRulesMetaContents, typesContents],
	);
};
