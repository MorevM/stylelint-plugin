import{_ as t,c as o,o as r,ae as s}from"./chunks/framework.1y2w2LY9.js";const d=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"_parts/bem-block.md","filePath":"docs/_parts/bem-block.md"}'),n={name:"_parts/bem-block.md"};function i(a,e,c,l,p,u){return r(),o("div",null,[...e[0]||(e[0]=[s('<details class="details custom-block"><summary>üß± How the BEM block is determined</summary><p>Some BEM linters ‚Äî like <a href="https://github.com/postcss/postcss-bem-linter" target="_blank" rel="noreferrer">postcss-bem-linter</a> ‚Äî require you to define the block name explicitly using a comment (<code>/** @define the-component */</code>) or derive it from the filename via configuration.</p><p>This plugin takes a different, much simpler approach:</p><hr><blockquote><p><strong>The first class selector in the file is considered the BEM block.</strong></p></blockquote><hr><p>‚úÖ <strong>Why this is enough</strong> <br> In a component-oriented architecture, there is rarely a reason to define more than one block per file. Assuming that the first top-level class represents the component&#39;s block is usually both practical and predictable ‚Äî without requiring additional annotations or configuration. <br> It also avoids coupling the rule to naming conventions or file structure.</p><hr><p>‚ùì <strong>What if you need more control?</strong> <br> If your project uses a different structure, this assumption may not work well.</p><p>This plugin doesn&#39;t currently support custom block resolution logic or in-file annotations ‚Äî mostly because there&#39;s little evidence it&#39;s needed. <br> But if you have a real use case ‚Äî feel free to open an issue and describe your use case.</p></details>',1)])])}const h=t(n,[["render",i]]);export{d as __pageData,h as default};
